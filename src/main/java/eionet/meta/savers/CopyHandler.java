package eionet.meta.savers;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import javax.servlet.ServletContext;

import org.apache.log4j.Logger;

import eionet.meta.DDSearchEngine;
import eionet.meta.DDUser;
import eionet.meta.DElemAttribute;
import eionet.meta.Tbl2ElmRelation;
import eionet.meta.dbschema.DbSchema;
import eionet.util.Util;
import eionet.util.sql.INParameters;
import eionet.util.sql.SQL;
import eionet.util.sql.SQLGenerator;

/**
 *
 * @author Jaanus Heinlaid
 *
 */
public class CopyHandler extends Object {

    /** */
    private static final Logger LOGGER = Logger.getLogger(CopyHandler.class);

    /**  */
    private Connection conn = null;

    /**  */
    private DDSearchEngine searchEngine = null;

    /**  */
    private ServletContext ctx = null;

    /**  */
    private DDUser user = null;

    /** */
    private Hashtable<String,String> oldNewElements = new Hashtable<String, String>();
    private Hashtable<String,String> oldNewTables = new Hashtable<String, String>();
    private Hashtable<String,String> oldNewDatasets = new Hashtable<String, String>();

    /** */
    private boolean isRecordOldNewMappings = false;

    /**
     *
     * @param conn
     * @param ctx
     * @param searchEngine
     */
    public CopyHandler(Connection conn, ServletContext ctx, DDSearchEngine searchEngine) {
        this.conn = conn;
        this.ctx = ctx;
        if (searchEngine != null) {
            this.searchEngine = searchEngine;
        } else {
            this.searchEngine = new DDSearchEngine(conn);
        }
    }

    /**
     *
     * @param user
     */
    public void setUser(DDUser user) {
        this.user = user;
    }

    /**
     *
     * @param dstGen
     * @param srcConstraint
     * @return
     * @throws SQLException
     */
    public String copy(SQLGenerator dstGen, String srcConstraint) throws SQLException {

        return copy(dstGen, srcConstraint, true);
    }

    /**
     * Create a working copy of an object. Table name and preset values of the working copy are given in <code>SQLGenerator</code>.
     * The <code>String</code> provides the constraint for selecting the object to copy (e.g. "DATAELEM_ID=123"). If the
     * <code>boolean</code> is <code>false</code>, the fields in <code>SQLGenerator</code> will not be selected from the original
     * and they will be omitted from the final insert query (i.e. they will be auto_generated by the DB).
     *
     * @param dstGen
     * @param srcConstraint
     * @param includeDstGenFields
     * @return id of the working copy.
     * @throws SQLException
     */
    public String copy(SQLGenerator dstGen, String srcConstraint, boolean includeDstGenFields) throws SQLException {

        if (dstGen == null) {
            return null;
        }
        srcConstraint = srcConstraint == null ? "" : " where " + srcConstraint;

        String tableName = dstGen.getTableName();
        Vector colNames = getTableColumnNames(tableName);
        if (colNames == null || colNames.size() == 0) {
            throw new SQLException("Failed to retreive any column names of this table: " + tableName);
        }

        String q = "select * from " + dstGen.getTableName() + srcConstraint;

        Statement stmt = null;
        Statement stmt1 = null;
        ResultSet rs = null;
        try {
            stmt = conn.createStatement();
            rs = stmt.executeQuery(q);
            while (rs.next()) {
                SQLGenerator gen = (SQLGenerator) dstGen.clone();
                for (int i = 0; i < colNames.size(); i++) {
                    String colName = (String) colNames.get(i);
                    String colValue = rs.getString(colName);
                    if ((dstGen.getFieldValue(colName)) == null) {
                        if (colValue != null) {
                            gen.setField(colName, colValue);
                        }
                    } else if (!includeDstGenFields) {
                        if (dstGen.getFieldValue(colName).equals("")) {
                            gen.removeField(colName);
                        }
                    }
                }
                LOGGER.debug(gen.insertStatement());

                if (stmt1 == null) {
                    stmt1 = conn.createStatement();
                }
                stmt1.executeUpdate(gen.insertStatement());
            }
        } finally {

            try {
                if (rs != null) {
                    rs.close();
                }
                if (stmt != null) {
                    stmt.close();
                }
                if (stmt1 != null) {
                    stmt1.close();
                }
            } catch (Exception e) {
            }
        }

        if (includeDstGenFields) {
            return null;
        } else {
            return searchEngine.getLastInsertID();
        }
    }

    /**
     *
     * @param tableName
     * @return
     * @throws SQLException
     */
    private Vector getTableColumnNames(String tableName) throws SQLException {

        Vector result = new Vector();
        if (tableName == null || tableName.length() == 0) {
            return result;
        }

        INParameters inParams = new INParameters();

        String q = "select * from " + tableName + " limit 0,1";

        int colCount = 0;
        PreparedStatement stmt = null;
        ResultSet rs = null;
        ResultSetMetaData rsmd = null;
        try {
            stmt = SQL.preparedStatement(q, inParams, conn);
            rs = stmt.executeQuery();
            rsmd = rs.getMetaData();
            if (rsmd != null) {
                colCount = rsmd.getColumnCount();
                for (int i = 1; colCount > 0 && i <= colCount; i++) {
                    String colName = rsmd.getColumnName(i);
                    if (colName != null && colName.length() > 0) {
                        result.add(colName);
                    }
                }
            }
        } finally {
            try {
                if (rs != null) {
                    rs.close();
                }
                if (stmt != null) {
                    stmt.close();
                }
            } catch (Exception e) {
            }
        }

        if (result.size() < colCount) {
            throw new SQLException("Failed to retreive names of all columns of this table: " + tableName);
        }

        return result;
    }

    /**
     *
     *
     * @param elmId
     * @param makeItWorkingCopy
     * @param isCopyTbl2ElmRelations
     * @param resetVersionAndStatus
     * @return
     * @throws Exception
     */
    public String copyElm(String elmId, boolean makeItWorkingCopy, boolean isCopyTbl2ElmRelations, boolean resetVersionAndStatus)
    throws Exception {

        if (elmId == null) {
            return null;
        }

        // copy row in DATAELEM table
        LOGGER.debug("Copying element row");
        Map<String, Object> newValues = toValueMap("DATE", Long.valueOf(System.currentTimeMillis()));
        if (makeItWorkingCopy) {
            newValues.put("WORKING_COPY", SQL.toLiteral("Y"));
        }
        if (user != null) {
            newValues.put("USER", SQL.toLiteral(user.getUserName()));
        }
        if (resetVersionAndStatus) {
            newValues.put("VERSION", Integer.valueOf(1));
            newValues.put("REG_STATUS", SQL.toLiteral("Incomplete"));
        } else {
            newValues.put("VERSION", "VERSION+1");
        }
        String newId = String.valueOf(copyAutoIncRow("DATAELEM", "DATAELEM_ID=" + elmId, "DATAELEM_ID", newValues));
        if (newId == null) {
            return null;
        }
        else if (isRecordOldNewMappings){
            oldNewElements.put(elmId, newId);
        }

        Statement stmt = null;
        try {
            stmt = conn.createStatement();

            // if requested, copy TBL2ELEM relations
            if (isCopyTbl2ElmRelations) {

                newValues = toValueMap("DATAELEM_ID", newId);
                String whereClause = "DATAELEM_ID=" + elmId;
                stmt.addBatch(rowsCopyStatement("TBL2ELEM", whereClause, newValues));
            }

            // statement for copying simple attributes
            stmt.addBatch(simpleAttrsCopyStatement(elmId, newId, "E"));

            // statements for copying complex-attributes
            stmt.addBatch(complexAttrRowsCopyStatement(elmId, newId, "E"));
            stmt.addBatch(complexAttrFieldsCopyStatement(elmId, newId, "E"));

            // statement for copying fixed values

            newValues = toValueMap("OWNER_ID", newId);
            newValues.put("FXV_ID", null);
            String whereClause = "OWNER_TYPE='elem' and OWNER_ID=" + elmId;
            stmt.addBatch(rowsCopyStatement("FXV", whereClause, newValues));

            // statements for copying foreign-key relations

            newValues = toValueMap("A_ID", newId);
            newValues.put("REL_ID", null);
            whereClause = "A_ID=" + elmId;
            stmt.addBatch(rowsCopyStatement("FK_RELATION", whereClause, newValues));
            newValues = toValueMap("B_ID", newId);
            newValues.put("REL_ID", null);
            whereClause = "B_ID=" + elmId;
            stmt.addBatch(rowsCopyStatement("FK_RELATION", whereClause, newValues));

            // execute the above batched statements
            LOGGER.debug("Copying the element's simple and complex attributes, fixed/suggested values and foreign-key relations");
            stmt.executeBatch();

        } finally {
            SQL.close(stmt);
        }

        return newId;
    }

    /*
     *
     */
    /**
     *
     *
     * @param elmID
     * @return
     * @throws Exception
     */
    public String convertElm(String elmID) throws Exception {

        if (elmID == null) {
            return null;
        }

        SQLGenerator gen = new SQLGenerator();
        gen.setTable("DATAELEM");
        gen.setField("DATAELEM_ID", "");
        String newID = copy(gen, "DATAELEM_ID=" + elmID, false);
        if (newID == null) {
            return null;
        }

        // copy rows in ATTRIBUTE, with lastInsertID
        gen.clear();
        gen.setTable("ATTRIBUTE");
        gen.setField("DATAELEM_ID", newID);
        copy(gen, "DATAELEM_ID=" + elmID + " and PARENT_TYPE='E'");

        // copy fixed values
        copyFxv(newID, elmID, "elem");

        return newID;
    }

    /**
     *
     *
     * @param newOwner
     * @param oldOwner
     * @param ownerType
     * @throws SQLException
     */
    public void copyFxv(String newOwner, String oldOwner, String ownerType) throws SQLException {

        INParameters inParams = new INParameters();

        String q =
            "select * from FXV where " + "OWNER_ID=" + inParams.add(oldOwner) + " and OWNER_TYPE=" + inParams.add(ownerType);

        Vector v = new Vector();
        PreparedStatement stmt = null;
        stmt = SQL.preparedStatement(q, inParams, conn);
        ResultSet rs = stmt.executeQuery();
        while (rs != null && rs.next()) {
            SQLGenerator gen = new SQLGenerator();
            gen.setTable("FXV");
            gen.setFieldExpr("OWNER_ID", newOwner);
            gen.setField("OWNER_TYPE", ownerType);
            gen.setField("VALUE", rs.getString("VALUE"));
            gen.setField("IS_DEFAULT", rs.getString("IS_DEFAULT"));
            gen.setField("DEFINITION", rs.getString("DEFINITION"));
            gen.setField("SHORT_DESC", rs.getString("SHORT_DESC"));
            v.add(gen);
        }
        rs.close();
        for (int i = 0; i < v.size(); i++) {
            SQLGenerator gen = (SQLGenerator) v.get(i);
            stmt.executeUpdate(gen.insertStatement());
        }

        stmt.close();
    }

    /**
     *
     * @param tblId
     * @return
     * @throws Exception
     */
    @SuppressWarnings({"rawtypes", "unchecked"})
    public String copyTbl(String tblId) throws Exception {

        if (tblId == null) {
            return null;
        }

        // copy row in DS_TABLE table
        LOGGER.debug("Copying table row");
        Map<String, Object> newValues = toValueMap("DATE", Long.valueOf(System.currentTimeMillis()));
        if (user != null) {
            newValues.put("USER", SQL.toLiteral(user.getUserName()));
        }
        String newId = String.valueOf(copyAutoIncRow("DS_TABLE", "TABLE_ID=" + tblId, "TABLE_ID", newValues));
        if (newId == null) {
            return null;
        }
        else if (isRecordOldNewMappings){
            oldNewTables.put(tblId, newId);
        }

        Statement stmt = null;
        ResultSet rs = null;
        try {
            stmt = conn.createStatement();

            LOGGER.debug("Copying the table's simple and complex attributes, and documents");

            // statement for copying simple attributes
            stmt.addBatch(simpleAttrsCopyStatement(tblId, newId, "T"));

            // statements for copying complex-attributes
            stmt.addBatch(complexAttrRowsCopyStatement(tblId, newId, "T"));
            stmt.addBatch(complexAttrFieldsCopyStatement(tblId, newId, "T"));

            // statement for copying documents
            stmt.addBatch(documentsCopyStatement(tblId, newId, "tbl"));

            // execute above-batched statements
            stmt.executeBatch();

        } finally {
            SQL.close(rs);
            SQL.close(stmt);
        }

        // copy table elements
        LOGGER.debug("Copying the table's elements");
        copyTableElements(tblId, newId);

        return newId;
    }

    /** */
    private static final String GET_TABLE_ELEMENTS = "select TBL2ELEM.DATAELEM_ID, TBL2ELEM.MULTIVAL_DELIM, TBL2ELEM.MANDATORY, "
        + "DATAELEM.PARENT_NS from TBL2ELEM left outer join DATAELEM on TBL2ELEM.DATAELEM_ID=DATAELEM.DATAELEM_ID "
        + "where DATAELEM.DATAELEM_ID is not null and TABLE_ID=? order by POSITION asc";

    /**
     *
     * @param oldTblId
     * @param newTblId
     * @throws Exception
     */
    private void copyTableElements(String oldTblId, String newTblId) throws Exception {

        ResultSet rs = null;
        PreparedStatement stmt = null;
        try {
            // Collect the ids of elements in the old table.

            stmt = SQL.preparedStatement(GET_TABLE_ELEMENTS, Collections.singletonList(Integer.valueOf(oldTblId)), conn);
            rs = stmt.executeQuery();

            ArrayList<Tbl2ElmRelation> oldRelations = new ArrayList<Tbl2ElmRelation>();
            while (rs.next()) {

                Tbl2ElmRelation relation = new Tbl2ElmRelation();
                relation.setElmId(rs.getInt("TBL2ELEM.DATAELEM_ID"));
                relation.setElmMultivalueDelimiter(rs.getString("TBL2ELEM.MULTIVAL_DELIM"));
                relation.setElmMandatory(rs.getBoolean("TBL2ELEM.MANDATORY"));
                relation.setElmCommon(rs.getString("DATAELEM.PARENT_NS") == null);
                oldRelations.add(relation);
            }
            SQL.close(rs);

            if (!oldRelations.isEmpty()) {

                LOGGER.debug("Found " + oldRelations.size() + " elements in table " + oldTblId);

                // Statement for relating new elements to new tables (uses multiple rows insert syntax).
                StringBuilder sql =
                    new StringBuilder("insert into TBL2ELEM (TABLE_ID,DATAELEM_ID,POSITION,MULTIVAL_DELIM,MANDATORY) values");

                int i = 1;
                for (Tbl2ElmRelation oldRelation : oldRelations) {

                    // Copy element, but only if it's non-common.
                    // Common elements will simply be linked to the new table (see further below).
                    String newElmId = null;
                    if (!oldRelation.isElmCommon()){
                        newElmId = copyElm(String.valueOf(oldRelation.getElmId()), false, false, false);
                    }

                    // Append new element / new table relation to the statement.
                    if (i > 1) {
                        sql.append(",");
                    }
                    sql.append("(");
                    sql.append(newTblId);
                    sql.append(",").append(oldRelation.isElmCommon() ? oldRelation.getElmId() : newElmId);
                    sql.append(",").append(i);
                    sql.append(",").append(SQL.toLiteral(oldRelation.getElmMultivalueDelimiter()));
                    sql.append(",").append(oldRelation.isElmMandatory());
                    sql.append(")");
                    i++;
                }

                LOGGER.debug("Copying table-to-element relations");
                stmt.executeUpdate(sql.toString());
            }
        } finally {
            SQL.close(rs);
            SQL.close(stmt);
        }
    }

    /**
     *
     * @param dstId
     * @param makeItWorkingCopy
     * @param resetVersionAndStatus
     * @return
     * @throws Exception
     */
    public String copyDst(String dstId, boolean makeItWorkingCopy, boolean resetVersionAndStatus) throws Exception {

        if (dstId == null) {
            return null;
        }

        // copy row in DATASET table
        LOGGER.debug("Copying dataset row");
        Map<String, Object> newValues = toValueMap("DATE", Long.valueOf(System.currentTimeMillis()));
        if (makeItWorkingCopy) {
            newValues.put("WORKING_COPY", SQL.toLiteral("Y"));
        }
        if (user != null) {
            newValues.put("USER", SQL.toLiteral(user.getUserName()));
        }
        if (resetVersionAndStatus) {
            newValues.put("VERSION", Integer.valueOf(1));
            newValues.put("REG_STATUS", SQL.toLiteral("Incomplete"));
        } else {
            newValues.put("VERSION", "VERSION+1");
        }
        String newId = String.valueOf(copyAutoIncRow("DATASET", "DATASET_ID=" + dstId, "DATASET_ID", newValues));
        if (newId == null) {
            return null;
        }
        else if (isRecordOldNewMappings){
            oldNewDatasets.put(dstId, newId);
        }

        Statement stmt = null;
        try {
            stmt = conn.createStatement();

            LOGGER.debug("Copying the dataset's simple and complex attributes, ROD links, and documents");

            // statement for copying simple attributes
            stmt.addBatch(simpleAttrsCopyStatement(dstId, newId, "DS"));

            // statements for copying complex-attributes
            stmt.addBatch(complexAttrRowsCopyStatement(dstId, newId, "DS"));
            stmt.addBatch(complexAttrFieldsCopyStatement(dstId, newId, "DS"));

            // statement for copying documents
            stmt.addBatch(documentsCopyStatement(dstId, newId, "dst"));

            // statement for copying ROD links
            newValues = toValueMap("DATASET_ID", newId);
            String whereClause = "DATASET_ID=" + dstId;
            stmt.addBatch(rowsCopyStatement("DST2ROD", whereClause, newValues));

            stmt.executeBatch();
        } finally {
            SQL.close(stmt);
        }

        // copy tables
        LOGGER.debug("Copying the dataset's tables");
        copyDstTables(dstId, newId);

        LOGGER.debug("Dataset copying finished");
        return newId;
    }

    /** */
    private static final String GET_DATASET_TABLES = "select TABLE_ID from DST2TBL where DATASET_ID=? order by POSITION asc";

    /**
     *
     * @param oldDstId
     * @param newDstId
     * @throws Exception
     */
    public void copyDstTables(String oldDstId, String newDstId) throws Exception {

        ResultSet rs = null;
        PreparedStatement stmt = null;
        try {
            // Collect the ids of tables in the old dataset.

            stmt = SQL.preparedStatement(GET_DATASET_TABLES, Collections.singletonList(Integer.valueOf(oldDstId)), conn);
            rs = stmt.executeQuery();

            ArrayList<String> oldTblIds = new ArrayList<String>();
            while (rs.next()) {
                oldTblIds.add(rs.getString(1));
            }
            SQL.close(rs);

            // Copy each table found in the old dataset, and relate new ones to the new dataset.

            if (!oldTblIds.isEmpty()) {

                LOGGER.debug("Found " + oldTblIds.size() + " tables in the dataset");

                int i = 1;
                // Statement for relating new tables to new dataset (uses multiple rows insert syntax).
                StringBuilder sql = new StringBuilder("insert into DST2TBL (DATASET_ID,TABLE_ID,POSITION) values");
                for (String oldTblId : oldTblIds) {

                    // Copy table.
                    String newTblId = copyTbl(oldTblId);
                    // Append new table / new dataset relation to the statement.
                    if (i > 1) {
                        sql.append(",");
                    }
                    sql.append("(").append(newDstId).append(",").append(newTblId).append(",").append(i).append(")");
                    i++;
                }

                LOGGER.debug("Copying dataset-to-table relations");

                stmt.executeUpdate(sql.toString());
            }
        } finally {
            SQL.close(rs);
            SQL.close(stmt);
        }
    }

    /**
     *
     *
     * @param newID
     * @param oldID
     * @param type
     * @throws SQLException
     */
    public void copyComplexAttrs(String newID, String oldID, String type) throws SQLException {
        copyComplexAttrs(newID, oldID, type, null, null);
    }

    /**
     *
     * @param newID
     * @param oldID
     * @param type
     * @param newType
     * @param mAttrID
     * @throws SQLException
     */
    public void copyComplexAttrs(String newID, String oldID, String type, String newType, String mAttrID) throws SQLException {

        if (newID == null || oldID == null || type == null) {
            return;
        }

        // get the attributes of the parent to copy and loop over them
        Vector v = searchEngine.getComplexAttributes(oldID, type, mAttrID);
        for (int i = 0; v != null && i < v.size(); i++) {

            DElemAttribute attr = (DElemAttribute) v.get(i);
            String attrID = attr.getID();

            // get the attribute fields
            Vector fields = searchEngine.getAttrFields(attrID);
            if (fields == null || fields.size() == 0) {
                continue;
            }

            Statement stmt = null;
            try {
                stmt = conn.createStatement();

                // get the attribute rows
                Vector valueRows = attr.getRows();
                for (int j = 0; valueRows != null && j < valueRows.size(); j++) {

                    Hashtable rowHash = (Hashtable) valueRows.get(j);
                    String rowPos = (String) rowHash.get("position");
                    rowPos = rowPos == null ? "0" : rowPos;

                    // insert a new row
                    if (newType != null) {
                        type = newType;
                    }
                    String rowID = "md5('" + newID + type + attrID + rowPos + "')";

                    SQLGenerator gen = new SQLGenerator();
                    gen.setTable("COMPLEX_ATTR_ROW");
                    gen.setField("PARENT_ID", newID);
                    gen.setField("PARENT_TYPE", type);
                    gen.setField("M_COMPLEX_ATTR_ID", attrID);
                    gen.setFieldExpr("ROW_ID", rowID);
                    gen.setFieldExpr("POSITION", rowPos);

                    // JH131103 - here we need to know if the attribute is linked to
                    // an harvested one
                    String harvAttrID = (String) rowHash.get("harv_attr_id");
                    if (harvAttrID != null) {
                        gen.setField("HARV_ATTR_ID", harvAttrID);
                    }

                    stmt.executeUpdate(gen.insertStatement());
                    if (harvAttrID != null) {
                        continue;
                    }

                    // get the value of each field in the given row
                    int insertedFields = 0;
                    for (int t = 0; rowID != null && t < fields.size(); t++) {
                        Hashtable fieldHash = (Hashtable) fields.get(t);
                        String fieldID = (String) fieldHash.get("id");
                        String fieldValue = (String) rowHash.get(fieldID);

                        // insert the field
                        if (fieldID != null && fieldValue != null) {

                            gen.clear();
                            gen.setTable("COMPLEX_ATTR_FIELD");
                            gen.setFieldExpr("ROW_ID", rowID);
                            gen.setField("M_COMPLEX_ATTR_FIELD_ID", fieldID);
                            gen.setField("VALUE", fieldValue);

                            StringBuffer buf =
                                new StringBuffer(gen.insertStatement()).append(" on duplicate key update VALUE=").append(
                                        eionet.util.sql.SQL.toLiteral(fieldValue));

                            stmt.executeUpdate(buf.toString());
                            insertedFields++;
                        }
                    }

                    // if no fields were actually inserted, delete the row
                    if (insertedFields == 0) {
                        stmt.executeUpdate("delete from COMPLEX_ATTR_ROW " + "where ROW_ID=" + rowID);
                    }
                }
            } catch (SQLException e) {
                e.printStackTrace(System.out);
                throw e;
            } finally {
                try {
                    if (stmt != null) {
                        stmt.close();
                    }
                } catch (SQLException e) {
                }
            }
        }
    }

    /**
     *
     *
     * @param newID
     * @param oldID
     * @param newType
     * @param oldType
     * @param mAttrID
     * @throws SQLException
     */
    public void copyAttribute(String newID, String oldID, String newType, String oldType, String mAttrID) throws SQLException {
        SQLGenerator gen = new SQLGenerator();
        gen.setTable("ATTRIBUTE");
        gen.setField("DATAELEM_ID", newID);
        gen.setField("PARENT_TYPE", newType);
        copy(gen, "M_ATTRIBUTE_ID=" + mAttrID + " and DATAELEM_ID=" + oldID + " and PARENT_TYPE='" + oldType + "'");
    }

    /**
     *
     *
     * @return
     * @throws SQLException
     */
    private String getLastInsertID() throws SQLException {

        return getLastInsertID(null);
    }

    /**
     *
     * @param stmt
     * @return
     * @throws SQLException
     */
    private String getLastInsertID(Statement stmt) throws SQLException {

        ResultSet rs = null;
        boolean statementGiven = stmt != null;
        try {
            if (!statementGiven) {
                stmt = conn.createStatement();
            }

            rs = stmt.executeQuery("SELECT LAST_INSERT_ID()");
            rs.clearWarnings();
            return rs.next() ? rs.getString(1) : null;
        } finally {
            if (!statementGiven) {
                SQL.close(stmt);
            }
        }
    }

    /**
     *
     * @param tableName
     * @param whereClause
     * @param autoIncColumn
     * @return
     * @throws SQLException
     */
    protected int copyAutoIncRow(String tableName, String whereClause, String autoIncColumn) throws SQLException {

        return copyAutoIncRow(tableName, whereClause, autoIncColumn, null);
    }

    /**
     *
     * @param tableName
     * @param whereClause
     * @param autoIncColumn
     * @param newValuesMap
     * @return
     * @throws SQLException
     */
    protected int
    copyAutoIncRow(String tableName, String whereClause, String autoIncColumn, final Map<String, Object> newValuesMap)
    throws SQLException {

        if (Util.isEmpty(tableName) || Util.isEmpty(autoIncColumn)) {
            throw new IllegalArgumentException("Table name and auto-increment column name must be given!");
        }

        Map<String, Object> map = newValuesMap == null ? new HashMap<String, Object>() : new HashMap<String, Object>(newValuesMap);
        map.put(autoIncColumn, null);
        String sql = rowsCopyStatement(tableName, whereClause, map);

        Statement stmt = null;
        try {
            stmt = conn.createStatement();
            stmt.executeUpdate(sql);
            try {
                return Integer.parseInt(getLastInsertID(stmt));
            } catch (Exception e) {
                return 0;
            }
        } finally {
            SQL.close(stmt);
        }
    }

    /**
     *
     * @param tableName
     * @param whereClause
     * @param newValuesMap
     * @return
     */
    protected static String rowsCopyStatement(String tableName, String whereClause, Map<String, Object> newValuesMap) {

        return rowsCopyStatement(tableName, tableName, whereClause, newValuesMap);
    }

    /**
     *
     * @param tableName
     * @param whereClause
     * @param newValues
     * @return
     */
    protected static String rowsCopyStatement(String tableName, String fromClause, String whereClause,
            Map<String, Object> newValuesMap) {

        if (Util.isEmpty(tableName)) {
            throw new IllegalArgumentException("Table name must be given!");
        }

        LinkedHashMap<String, Object> newValues = new LinkedHashMap<String, Object>();
        if (newValuesMap != null) {
            newValues.putAll(newValuesMap);
        }
        boolean isNewValuesEmpty = Util.isEmpty(newValues);

        List<String> columnNames = DbSchema.getTableColumns(tableName, isNewValuesEmpty ? null : newValues.keySet());
        boolean isColumnNamesEmpty = Util.isEmpty(columnNames);

        StringBuilder sql = new StringBuilder();

        if (isNewValuesEmpty && isColumnNamesEmpty) {

            sql.append("insert into ").append(tableName).append(" select * from ").append(fromClause);

        } else {

            sql.append("insert into ").append(tableName).append(" (");

            int i = 0;
            if (!isNewValuesEmpty) {
                for (String columnName : newValues.keySet()) {
                    sql.append(i++ > 0 ? "," : "").append(columnName);
                }
            }

            String columnNamesCSV = Util.toCSV(columnNames);
            if (!isColumnNamesEmpty) {
                sql.append(i == 0 ? "" : ",").append(columnNamesCSV);
            }

            sql.append(") select ");

            i = 0;
            if (!isNewValuesEmpty) {
                for (Object value : newValues.values()) {
                    sql.append(i++ > 0 ? "," : "").append(value == null ? "NULL" : value);
                }
            }

            if (!isColumnNamesEmpty) {
                sql.append(i == 0 ? "" : ",").append(columnNamesCSV);
            }

            sql.append(" from ").append(fromClause);
        }

        if (!Util.isEmpty(whereClause)) {
            sql.append(" where ").append(whereClause);
        }

        return sql.toString();
    }

    /**
     *
     * @param key
     * @param value
     * @return
     */
    private static Map<String, Object> toValueMap(String key, Object value) {

        HashMap<String, Object> map = new HashMap<String, Object>();
        map.put(key, value);
        return map;
    }

    /**
     *
     * @param oldId
     * @param newId
     * @param parentType
     * @return
     */
    protected static String simpleAttrsCopyStatement(String oldId, String newId, String parentType) {

        Map<String, Object> newValues = toValueMap("DATAELEM_ID", newId);
        String whereClause = "PARENT_TYPE='" + parentType + "' and DATAELEM_ID=" + oldId;
        return rowsCopyStatement("ATTRIBUTE", whereClause, newValues);
    }

    /**
     *
     * @param oldId
     * @param newId
     * @param parentType
     * @return
     */
    protected static String complexAttrRowsCopyStatement(String oldId, String newId, String parentType) {

        Map<String, Object> newValues = toValueMap("PARENT_ID", newId);
        newValues.put("ROW_ID", "md5(concat('" + newId + "',PARENT_TYPE,M_COMPLEX_ATTR_ID,POSITION))");
        String whereClause = "PARENT_TYPE='" + parentType + "' and PARENT_ID=" + oldId;
        return rowsCopyStatement("COMPLEX_ATTR_ROW", whereClause, newValues);
    }

    /**
     *
     * @param oldId
     * @param newId
     * @param parentType
     * @return
     */
    protected static String complexAttrFieldsCopyStatement(String oldId, String newId, String parentType) {

        Map<String, Object> newValues =
            toValueMap("ROW_ID", "md5(concat('" + newId + "',PARENT_TYPE,M_COMPLEX_ATTR_ID,POSITION))");
        String fromClause = "COMPLEX_ATTR_FIELD,COMPLEX_ATTR_ROW";
        String whereClause =
            "COMPLEX_ATTR_FIELD.ROW_ID=COMPLEX_ATTR_ROW.ROW_ID and PARENT_TYPE='" + parentType + "' and PARENT_ID=" + oldId;
        return rowsCopyStatement("COMPLEX_ATTR_FIELD", fromClause, whereClause, newValues);
    }

    /**
     *
     * @param oldId
     * @param newId
     * @param ownerType
     * @return
     */
    protected static String documentsCopyStatement(String oldId, String newId, String ownerType) {

        Map<String, Object> newValues = toValueMap("OWNER_ID", newId);
        String whereClause = "OWNER_TYPE='" + ownerType + "' and OWNER_ID=" + oldId;
        return rowsCopyStatement("DOC", whereClause, newValues);
    }

    /**
     * @param isRecordOldNewMappings the isRecordOldNewMappings to set
     */
    protected void setRecordOldNewMappings(boolean isRecordOldNewMappings) {
        this.isRecordOldNewMappings = isRecordOldNewMappings;
    }

    /**
     * @return the oldNewElements
     */
    protected Hashtable<String, String> getOldNewElements() {
        return oldNewElements;
    }

    /**
     * @return the oldNewTables
     */
    protected Hashtable<String, String> getOldNewTables() {
        return oldNewTables;
    }

    /**
     * @return the oldNewDatasets
     */
    protected Hashtable<String, String> getOldNewDatasets() {
        return oldNewDatasets;
    }
}
